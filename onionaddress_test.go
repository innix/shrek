package shrek_test

import (
	"bytes"
	"fmt"
	"testing"

	"github.com/innix/shrek"
)

const (
	// seed is the seed for the RNG.
	seed = "1qacdvcdfesg45w543tgfebfcdxfff0z"

	// seedHostname is the hostname generated by the RNG using the seed const.
	seedHostname = "bqyqcmzsemahixz7mre4m47qi2n65emwu4wjq2qefb7lin7jkkjbleid"
)

var (
	// seedPublicKey is the public key generated by the RNG using the seed const.
	seedPublicKey = []byte{
		0xc, 0x31, 0x1, 0x33, 0x32, 0x23, 0x0, 0x74, 0x5f, 0x3f, 0x64, 0x49, 0xc6, 0x73, 0xf0, 0x46, 0x9b, 0xee, 0x91,
		0x96, 0xa7, 0x2c, 0x98, 0x6a, 0x4, 0x28, 0x7e, 0xb4, 0x37, 0xe9, 0x52, 0x92,
	}

	// seedSecretKey is the private key generated by the RNG using the seed const.
	seedSecretKey = []byte{
		0x31, 0x71, 0x61, 0x63, 0x64, 0x76, 0x63, 0x64, 0x66, 0x65, 0x73, 0x67, 0x34, 0x35, 0x77, 0x35, 0x34, 0x33,
		0x74, 0x67, 0x66, 0x65, 0x62, 0x66, 0x63, 0x64, 0x78, 0x66, 0x66, 0x66, 0x30, 0x7a, 0xc, 0x31, 0x1, 0x33,
		0x32, 0x23, 0x0, 0x74, 0x5f, 0x3f, 0x64, 0x49, 0xc6, 0x73, 0xf0, 0x46, 0x9b, 0xee, 0x91, 0x96, 0xa7, 0x2c,
		0x98, 0x6a, 0x4, 0x28, 0x7e, 0xb4, 0x37, 0xe9, 0x52, 0x92,
	}
)

func TestOnionAddress_HostName(t *testing.T) {
	t.Parallel()

	addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
	if err != nil {
		t.Fatalf("Could not generate the prerequisite onion address: %v", err)
	}

	// Perform several iterations to ensure function is stateless and deterministic.
	for i := 0; i < 3; i++ {
		wanted := seedHostname
		got := make([]byte, shrek.EncodedPublicKeySize)
		addr.HostName(got)

		if string(got) != wanted {
			t.Errorf("Public key not encoded correctly, got: %q, wanted: %q", got, wanted)
		}
	}
}

func TestOnionAddress_HostName_BadBuffer(t *testing.T) {
	t.Parallel()

	addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
	if err != nil {
		t.Fatalf("Could not generate the prerequisite onion address: %v", err)
	}

	table := []struct {
		ExpectPanic bool
		Buffer      []byte
	}{
		{ExpectPanic: true, Buffer: make([]byte, 0)},
		{ExpectPanic: true, Buffer: make([]byte, shrek.EncodedPublicKeySize-1)},
		{ExpectPanic: true, Buffer: make([]byte, shrek.EncodedPublicKeySize*2)},
		{ExpectPanic: false, Buffer: make([]byte, shrek.EncodedPublicKeySize)},
	}

	for _, tc := range table {
		tc := tc
		name := fmt.Sprintf("buflen=%d_expectpanic=%v", len(tc.Buffer), tc.ExpectPanic)

		t.Run(name, func(t *testing.T) {
			t.Parallel()

			defer func() {
				if panicked := recover() != nil; panicked != tc.ExpectPanic {
					if tc.ExpectPanic {
						t.Error("Expected panic, none was detected.")
					} else {
						t.Error("Did not expect panic, one was detected.")
					}
				}
			}()

			addr.HostName(tc.Buffer)
		})
	}
}

func TestOnionAddress_HostNameString(t *testing.T) {
	t.Parallel()

	addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
	if err != nil {
		t.Fatalf("Could not generate the prerequisite onion address: %v", err)
	}

	// Perform several iterations to ensure function is stateless and deterministic.
	for i := 0; i < 3; i++ {
		wanted := fmt.Sprintf("%s.onion", seedHostname)
		got := addr.HostNameString()

		if got != wanted {
			t.Errorf("Public key not encoded correctly, got: %q, wanted: %q", got, wanted)
		}
	}
}

func TestOnionAddress_HostNameApprox(t *testing.T) {
	t.Parallel()

	addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
	if err != nil {
		t.Fatalf("Could not generate the prerequisite onion address: %v", err)
	}

	// Perform several iterations to ensure function is stateless and deterministic.
	for i := 0; i < 3; i++ {
		wanted := seedHostname
		got := make([]byte, shrek.EncodedPublicKeySize)
		addr.HostNameApprox(got)

		if string(got[:shrek.EncodedPublicKeyApproxSize]) != wanted[:shrek.EncodedPublicKeyApproxSize] {
			t.Errorf("Public key not encoded correctly, got: %q, wanted: %q", got, wanted)
		}
	}
}

func TestGenerateOnionAddress(t *testing.T) {
	t.Parallel()

	// Perform several iterations to ensure function is stateless and deterministic.
	for i := 0; i < 3; i++ {
		addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
		if err != nil {
			t.Fatalf("Could not generate the prerequisite onion address: %v", err)
		}

		if !bytes.Equal(addr.PublicKey, seedPublicKey) {
			t.Errorf("Unexpected public key, got: %v, wanted: %v", addr.PublicKey, seedPublicKey)
		}
		if !bytes.Equal(addr.SecretKey, seedSecretKey) {
			t.Errorf("Unexpected secret key, got: %v, wanted: %v", addr.SecretKey, seedSecretKey)
		}
	}
}

func TestGenerateOnionAddressSlow(t *testing.T) {
	t.Parallel()

	// Perform several iterations to ensure function is stateless and deterministic.
	for i := 0; i < 3; i++ {
		addr, err := shrek.GenerateOnionAddressSlow(bytes.NewBufferString(seed))
		if err != nil {
			t.Fatalf("Could not generate the prerequisite onion address: %v", err)
		}

		if !bytes.Equal(addr.PublicKey, seedPublicKey) {
			t.Errorf("Unexpected public key, got: %v, wanted: %v", addr.PublicKey, seedPublicKey)
		}
		if !bytes.Equal(addr.SecretKey, seedSecretKey) {
			t.Errorf("Unexpected secret key, got: %v, wanted: %v", addr.SecretKey, seedSecretKey)
		}
	}
}

func BenchmarkOnionAddress_HostName(b *testing.B) {
	addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
	if err != nil {
		b.Fatalf("Could not generate the prerequisite onion address: %v", err)
	}
	hostname := make([]byte, shrek.EncodedPublicKeySize)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		addr.HostName(hostname)
	}
}

func BenchmarkOnionAddress_HostNameApprox(b *testing.B) {
	addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
	if err != nil {
		b.Fatalf("Could not generate the prerequisite onion address: %v", err)
	}
	hostname := make([]byte, shrek.EncodedPublicKeySize)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		addr.HostNameApprox(hostname)
	}
}

func BenchmarkGenerateOnionAddress(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_, err := shrek.GenerateOnionAddress(nil)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkGenerateOnionAddressSlow(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_, err := shrek.GenerateOnionAddressSlow(nil)
		if err != nil {
			b.Fatal(err)
		}
	}
}
