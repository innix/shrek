package shrek_test

import (
	"bytes"
	"fmt"
	"testing"

	"github.com/innix/shrek"
)

const (
	// seed is the seed for the RNG.
	seed = "12D345Y678g9X0qwKertIyhOgbnDXmjhgvfdcHxswq12w3De4r5t6y7Vu8i9oT0pmnbKvcxzF"

	// seedHostname is the hostname generated by the RNG using the seed const.
	seedHostname = "if62hgkxq6r7c3slwqaj3fhj6in7bcceinhqz7nt7jy6dk77gw4towid"
)

var (
	// seedPublicKey is the public key generated by the RNG using the seed const.
	seedPublicKey = []byte{
		65, 125, 163, 153, 87, 135, 163, 241, 110, 75, 180, 0, 157, 148, 233, 242,
		27, 240, 136, 68, 67, 79, 12, 253, 179, 250, 113, 225, 171, 255, 53, 185,
	}

	// seedSecretKey is the private key generated by the RNG using the seed const.
	seedSecretKey = []byte{
		224, 52, 184, 160, 72, 18, 130, 195, 179, 118, 143, 220, 68, 119, 107, 106,
		133, 224, 81, 56, 152, 1, 136, 195, 2, 132, 2, 22, 233, 126, 231, 96, 101,
		25, 142, 250, 122, 147, 138, 100, 183, 254, 174, 193, 28, 184, 254, 251,
		154, 205, 94, 104, 106, 84, 161, 23, 92, 126, 34, 187, 241, 101, 129, 69,
	}
)

func TestOnionAddress_HostName(t *testing.T) {
	t.Parallel()

	addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
	if err != nil {
		t.Fatalf("could not generate the prerequisite onion address: %v", err)
	}

	wanted := seedHostname
	got := make([]byte, shrek.EncodedPublicKeySize)
	addr.HostName(got)

	if string(got) != wanted {
		t.Errorf("public key not encoded correctly, got: %q, wanted: %q", got, wanted)
	}
}

func TestOnionAddress_HostName_BadBuffer(t *testing.T) {
	t.Parallel()

	addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
	if err != nil {
		t.Fatalf("could not generate the prerequisite onion address: %v", err)
	}

	table := []struct {
		ExpectPanic bool
		Buffer      []byte
	}{
		{ExpectPanic: true, Buffer: make([]byte, 0)},
		{ExpectPanic: true, Buffer: make([]byte, shrek.EncodedPublicKeySize-1)},
		{ExpectPanic: true, Buffer: make([]byte, shrek.EncodedPublicKeySize*2)},
		{ExpectPanic: false, Buffer: make([]byte, shrek.EncodedPublicKeySize)},
	}

	for _, tc := range table {
		tc := tc
		name := fmt.Sprintf("buflen=%d_expectpanic=%v", len(tc.Buffer), tc.ExpectPanic)

		t.Run(name, func(t *testing.T) {
			t.Parallel()

			defer func() {
				if panicked := recover() != nil; panicked != tc.ExpectPanic {
					if tc.ExpectPanic {
						t.Error("expected panic, none was detected")
					} else {
						t.Error("did not expect panic, one was detected")
					}
				}
			}()

			addr.HostName(tc.Buffer)
		})
	}
}

func TestOnionAddress_HostNameString(t *testing.T) {
	t.Parallel()

	addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
	if err != nil {
		t.Fatalf("could not generate the prerequisite onion address: %v", err)
	}

	wanted := fmt.Sprintf("%s.onion", seedHostname)
	got := addr.HostNameString()

	if got != wanted {
		t.Errorf("public key not encoded correctly, got: %q, wanted: %q", got, wanted)
	}
}

func TestOnionAddress_HostNameApprox(t *testing.T) {
	t.Parallel()

	addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
	if err != nil {
		t.Fatalf("could not generate the prerequisite onion address: %v", err)
	}

	// Perform several iterations to ensure function is stateless and deterministic.
	for i := 0; i < 3; i++ {
		wanted := seedHostname
		got := make([]byte, shrek.EncodedPublicKeySize)
		addr.HostNameApprox(got)

		if string(got[:shrek.EncodedPublicKeyApproxSize]) != wanted[:shrek.EncodedPublicKeyApproxSize] {
			t.Errorf("public key not encoded correctly, got: %q, wanted: %q", got, wanted)
		}
	}
}

func TestGenerateOnionAddress(t *testing.T) {
	t.Parallel()

	addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
	if err != nil {
		t.Fatalf("could not generate the prerequisite onion address: %v", err)
	}

	if !bytes.Equal(addr.PublicKey, seedPublicKey) {
		t.Errorf("unexpected public key, got: %v, wanted: %v", addr.PublicKey, seedPublicKey)
	}
	if !bytes.Equal(addr.SecretKey, seedSecretKey) {
		t.Errorf("unexpected secret key, got: %v, wanted: %v", addr.SecretKey, seedSecretKey)
	}
}

func BenchmarkOnionAddress_HostName(b *testing.B) {
	addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
	if err != nil {
		b.Fatalf("could not generate the prerequisite onion address: %v", err)
	}
	hostname := make([]byte, shrek.EncodedPublicKeySize)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		addr.HostName(hostname)
	}
}

func BenchmarkOnionAddress_HostNameApprox(b *testing.B) {
	addr, err := shrek.GenerateOnionAddress(bytes.NewBufferString(seed))
	if err != nil {
		b.Fatalf("could not generate the prerequisite onion address: %v", err)
	}
	hostname := make([]byte, shrek.EncodedPublicKeySize)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		addr.HostNameApprox(hostname)
	}
}

func BenchmarkGenerateOnionAddress(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_, err := shrek.GenerateOnionAddress(nil)
		if err != nil {
			b.Fatalf("onion address generator errored unexpectedly during benchmark: %v", err)
		}
	}
}
